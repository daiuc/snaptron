---
params:
    tissue: Muscle
    group: 
    - group0
    - group1
    - group2
    p_cutoff: 1e-8
    denom_cutoff: 30
    ir_dist_cutoff: 0.1
title: "LeafcutterMD Analyses - GTEx `r params$tissue`"
author: "Chao Dai"
date: "updated `r Sys.Date()`"

output: 
  bookdown::html_document2:
    toc: yes
    toc_float: no
    theme: readable
    highlight: textmate
    code_folding: hide
    df_print: paged
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = F, message = F, echo = F)

library(tidyverse)
library(data.table)
library(ggrastr)
library(ggrepel)
library(DT)
library(tictoc)
library(forcats)

theme_set(new = theme_bw())
```

```{r helper-functions, include=FALSE}
# convert a string entry such as "3/4" in to a double "0.75"
# counts file were stored as string of fractions
frac_to_dbl = function(frac_str) {
  frac = str_split(frac_str, "/", simplify=T) %>% as.numeric
  if (frac[[1]] == 0) {
    out = 0
  } else {
    out = frac[[1]] / frac[[2]]
  }
  return(out)
}



get_denom = function(frac_str) {
  # get denominator from a fraction string, eg. get 4 from "3/4"
  frac = str_split(frac_str, "/", simplify=T) %>% as.numeric
  return(frac[[2]])
}
```

```{r}

# define function based on quantiles
# the IR of the 96th quantile > 2 * SD of the IR of the first 95th quantile
quantilePass = function(v, quantile.threshold = .95, sd.multiplier = 2){
  lower.v = v[which(v <= quantile(v, quantile.threshold))]
  lower.sd = sd(lower.v)
  
  higher.v = v[which(v > quantile(v, quantile.threshold))]
  
  # if the median of 96th-100th is greather than 2*SD away from the 95th quantile, then pass
  pass.flag <- median(higher.v) >= sd.multiplier * lower.sd + quantile(v, quantile.threshold)
  return(pass.flag)
}

# or also bring in the denominator critiera,
# such that quantiles are only computed on samples with at least certain read counts
# not used 
quantilePass2 = function(dt, quantile.threshold = .95, sd.multiplier = 2){
  dt = dt[denom > 30]
  v = dt[, ir]
  lower.v = v[which(v <= quantile(v, quantile.threshold))]
  lower.sd = sd(lower.v)
  
  higher.v = v[which(v > quantile(v, quantile.threshold))]
  
  # if the median of 96th-100th is greather than 2*SD away from the 95th quantile, then pass
  pass.flag <- median(higher.v) >= sd.multiplier * lower.sd + quantile(v, quantile.threshold)
  return(pass.flag)
}
```


<!-- ---------------------------------------------------- -->

# GTEx `r params$tissue` {.tabset}



## `r params$group[[1]]`

```{r}
# load Bladder intron level pvals
tissue = params$tissue
group = params$group[[1]]
p_cutoff = as.numeric(params$p_cutoff)
denom_cutoff = as.numeric(params$denom_cutoff)
ir_dist_cutoff = as.numeric(params$ir_dist_cutoff)
```

```{r}
intron = fread(paste0("../code/results/leafcutterMD/GTEx/", tissue, "/",  group, "_pVals.txt.gz"))
#cluster = fread(paste0("../code/results/leafcutterMD/GTEx/", tissue , "/", group, "_clusterPvals.txt.gz"))
nums = fread(paste0("../code/results/SubsetCounts/GTEx/", tissue, "/nums_filtered/", group, "_perind.nums.gz"))
counts = fread(paste0("../code/results/SubsetCounts/GTEx/", tissue, "/counts/", group, "_perind.counts.gz"),
               header = T)

# rename first column
intron = rename(intron, "chrom" = "V1")
nums = rename(nums, "chrom" = "V1")

# add rowMin
intron_rowMins = select(intron, where(is_numeric)) %>% apply(1, min)
intron$rowMins = intron_rowMins # add min p-val per intron
```

### Intron selection

An intron excision is considered outlier only if: 

  1.  p-value of a given intron excision event \< `r scales::scientific(p_cutoff)`
  2.  **AND** total reads of the cluster \> `r denom_cutoff`
  3. **AND** intron excision ratio is at least `r params$ir_dist_cutoff` away from median

```{r}

# data.table of introns with that have outlier events
# note this is not the final outlier introns yet, as 
# we have to also filter by denominator
outlier_introns = intron[ rowMins < p_cutoff, -c('rowMins')] %>% unique

# get the counts of the same introns
outlier_counts = counts[chrom %in% outlier_introns$chrom]

# melt outlier intron and counts
outlier_introns = melt(outlier_introns, id.vars = "chrom", variable.name = "samples", value.name = "p")
outlier_counts = melt(outlier_counts, id.vars = "chrom", variable.name = "samples", value.name = "frac")

# further filter by denominator
outlier_introns = outlier_introns[outlier_counts, on = c("chrom", "samples"), nomatch = NULL]
```

```{r}
library(furrr)
plan(multisession, workers = availableCores())

denom = future_map_dbl(outlier_introns$frac, get_denom)
ir = future_map_dbl(outlier_introns$frac, frac_to_dbl)

outlier_introns$denom = denom
outlier_introns$ir = ir

```

```{r}
# add in reads
outlier_introns = melt(nums, id.vars = "chrom", variable.name = "samples", value.name = "rc")[
  outlier_introns, on = c("chrom", "samples"), nomatch = NULL
]

# artificially impute ir and rc when below condition meets
# the purpose is to remove ir=1 where read counts are low
outlier_introns[ir == 1 & rc < 10, `:=`(rc = 0, ir = 0)]
```

```{r}
# median IR per intron
outlier_introns[, median_ir := median(ir), by = chrom]
outlier_introns[, dist_ir := abs(median_ir - ir)]

# putative outlier
outlier_introns[, outlier := p < p_cutoff & denom > denom_cutoff & dist_ir > ir_dist_cutoff]

# outlier intron ids
outlier_introns_chroms = outlier_introns[outlier == T, chrom] %>% unique

outlier_introns = outlier_introns[chrom %in% outlier_introns_chroms]
```






 Some samples have many more outlier splicing events
```{r, width = 8}
outlier_introns[outlier == T][, .(N = length(unique(chrom))), by = samples] %>% 
  ggplot()  + geom_col(aes(fct_reorder(samples, -N), N, fill = samples)) + 
    geom_text_repel(aes(fct_reorder(samples, -N), N, label = samples), 
                    data = outlier_introns[outlier == T][, .(N = length(unique(chrom))), by = samples][N > 500]) + 
    labs(x = NULL) + 
    scale_y_log10() + 
    theme_bw() +
    theme(legend.position = "None", axis.text.x = element_blank())
```




#### Box plot before quantile filter

There are `r outlier_introns[outlier == T, chrom] %>% unique %>% length` outlier introns. 

```{r fig.width=10, fig.height=6, fig.cap="without filters"}

excl_samples = outlier_introns[ outlier == T, .( N = length(unique(chrom))), by = samples][N > 500, samples] %>% as.character
select_chroms = outlier_introns[!samples %in% excl_samples][order(p), chrom] %>% unique %>% head(50)

p2 = outlier_introns[chrom %in% select_chroms] %>% 
  ggplot() + geom_boxplot(aes(fct_reorder(chrom, p, min), ir)) + 
    geom_point(aes(fct_reorder(chrom, p, min), ir, color = outlier), alpha = .4) +
    geom_text_repel(aes(fct_reorder(chrom, p, min), ir, label = samples), 
                    data = outlier_introns[chrom %in% select_chroms & outlier == T & ir == 0]) + 
    labs(x = NULL, y = "Intron excision ratio") + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))

rasterize(p2, layers = "point", dpi=50)
```

```{r fig.width=10, fig.height=6}

excl_samples = outlier_introns[ outlier == T, .( N = length(unique(chrom))), by = samples][N > 500, samples] %>% as.character
select_chroms = outlier_introns[!samples %in% excl_samples][order(p), chrom] %>% unique %>% head(50)

p2 = outlier_introns[chrom %in% select_chroms] %>% 
  ggplot() + geom_boxplot(aes(fct_reorder(chrom, p, min), rc)) + 
    geom_point(aes(fct_reorder(chrom, p, min), rc, color = outlier), alpha = .4) +
    labs(x = NULL, y = "reads") + 
    scale_y_log10() + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))

rasterize(p2, layers = "point", dpi=50)
```

### Further filter outlier introns by comparing excision quantiles

By definition, outlier splicing events are ones that occur only in a few individuals. Here, I further enforced this quantile based filter: 

- assumes that it occurs in only up to 5% of samples,
- thus the excision ratio of the first 95% of samples should be largely different than that of the last 5% of samples
- here, I will only consider the case where the first 95% of samples have much lower excision ratio, because the complementary set always exists for a intron cluster. But we only want to select the intron once. 
- Specifically, an outlier intron is qualified only if the median excision ratio of samples in the (95, 100] percentiles is more than 2 std away from the median excision ratio of samples in the (0, 95] percentiles. 

In addition, for any intron usage of a sample where excision ratio is 1 and observed read counts < 10, read counts and excision ratio is forced to 0. This helps remove inflated excision ratio of 1 under such scenarios.




```{r}
qtPassed_chroms = outlier_introns[!samples %in% excl_samples, .(qtPass = quantilePass(ir)), by = chrom][qtPass == T, chrom] %>% unique
```


There are `r length(unique(qtPassed_chroms))` outlier introns after this round of quantil based filter. The box plot below randomly select 50 out of the outlier introns (x is sorted by p value). 

In summary, the two box plots below plotted some of the outlier introns that satisfy these crieria: 

  1.  p-value of a given intron excision event \< `r scales::scientific(p_cutoff)`
  2.  **AND** total reads of the cluster \> `r denom_cutoff`
  3. **AND** intron excision ratio is at least `r params$ir_dist_cutoff` away from median
  4. **AND** quantile filter described above
  5. **AND** exclude outliers from extrem samples


```{r, fig.width=12, fig.retina=T}

x = qtPassed_chroms[sample(1:length(qtPassed_chroms), 50)]

outlier_introns[chrom %in% x] %>% 
  ggplot() + geom_boxplot(aes(fct_reorder(chrom, p, min), ir)) + 
    geom_point(aes(fct_reorder(chrom, p, min), ir, color = outlier, shape = outlier), alpha = .4, position = "jitter") +
    geom_text_repel(aes(fct_reorder(chrom, p, min), ir, label = samples), 
                    data = outlier_introns[chrom %in% select_chroms & outlier == T & ir == 0]) + 
    labs(x = NULL, y = "Intron excision ratio") + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))
```

```{r, fig.width=12, fig.retina=T}
outlier_introns[chrom %in% x] %>% 
  ggplot() + geom_boxplot(aes(fct_reorder(chrom, p, min), rc)) + 
    geom_point(aes(fct_reorder(chrom, p, min), rc, color = outlier, shape = outlier), alpha = .4, position = "jitter") +
    scale_y_log10() + 
    labs(x = NULL, y = "reads") + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))
```




### extreme samples: `r excl_samples`

```{r}
samples_set1 = outlier_introns[outlier == T][
  , .(N = length(unique(chrom))), by = samples][
    N > 500, samples
  ] %>% as.character

samples_set2 = outlier_introns[outlier == T][
  , .(N = length(unique(chrom))), by = samples][
    N < 100, samples
  ] %>% as.character

GTEx = fread("../code/resources/snaptron-yil/scripts/data/samples_gtex.tsv")

```


Samples with > 500 outliers

```{r}
set1_gtex_ids = GTEx[rail_id %in% samples_set1][, SAMPID]
GTEx[rail_id %in% samples_set1][
  , .(rail_id, Sex, AGE, Histological_Type, Analyte_Type, SMPTHNTS, SMSMPSTE, SMSTYP, SMNABTCHT, TRTPTREF, DTHFUCOD, DTHMNNR, SAMPID)
]

```


Samples with less than 100 outliers
```{r}

GTEx[rail_id %in% samples_set2][
  , .(rail_id, Sex, AGE, Histological_Type, Analyte_Type, SMPTHNTS, SMSMPSTE, SMSTYP, SMNABTCHT, TRTPTREF, DTHFUCOD, DTHMNNR, SAMPID)
] %>% head
```

Notice the outlier sample is not included in the open access dataset from GTEx. One of the reasons may be that the sample did not pass QC filters.
```{r, include=TRUE}
# GTEx muscle TPM
gtex.tpm = fread("../code/resources/GTEx-downloads/gene_tpm_2017-06-05_v8_muscle_skeletal.gct.gz")
intersect(set1_gtex_ids, colnames(gtex.tpm))
# pca = prcomp(gtex.tpm[, 4:165] %>% t)
# 
# pca$x %>% as.data.frame %>% rownames_to_column("sampleID") %>%
#   select(1:5) %>% 
#   mutate(outlier = sampleID  %in% c("GTEX-VUSG-2626-SM-5S2TM"))
```



```{r include=FALSE}
rm(intron, counts, denom, outlier_introns, nums)
gc()
```





## `r params$group[[2]]`

```{r}
# load Bladder intron level pvals
tissue = params$tissue
group = params$group[[2]]
p_cutoff = as.numeric(params$p_cutoff)
denom_cutoff = as.numeric(params$denom_cutoff)
ir_dist_cutoff = as.numeric(params$ir_dist_cutoff)
```

```{r}
intron = fread(paste0("../code/results/leafcutterMD/GTEx/", tissue, "/",  group, "_pVals.txt.gz"))
#cluster = fread(paste0("../code/results/leafcutterMD/GTEx/", tissue , "/", group, "_clusterPvals.txt.gz"))
nums = fread(paste0("../code/results/SubsetCounts/GTEx/", tissue, "/nums_filtered/", group, "_perind.nums.gz"))
counts = fread(paste0("../code/results/SubsetCounts/GTEx/", tissue, "/counts/", group, "_perind.counts.gz"),
               header = T)

# rename first column
intron = rename(intron, "chrom" = "V1")
nums = rename(nums, "chrom" = "V1")

# add rowMin
intron_rowMins = select(intron, where(is_numeric)) %>% apply(1, min)
intron$rowMins = intron_rowMins # add min p-val per intron
```

### Intron selection

An intron excision is considered outlier only if: 

  1.  p-value of a given intron excision event \< `r scales::scientific(p_cutoff)`
  2.  **AND** total reads of the cluster \> `r denom_cutoff`
  3. **AND** intron excision ratio is at least `r params$ir_dist_cutoff` away from median

```{r}

# data.table of introns with that have outlier events
# note this is not the final outlier introns yet, as 
# we have to also filter by denominator
outlier_introns = intron[ rowMins < p_cutoff, -c('rowMins')] %>% unique

# get the counts of the same introns
outlier_counts = counts[chrom %in% outlier_introns$chrom]

# melt outlier intron and counts
outlier_introns = melt(outlier_introns, id.vars = "chrom", variable.name = "samples", value.name = "p")
outlier_counts = melt(outlier_counts, id.vars = "chrom", variable.name = "samples", value.name = "frac")

# further filter by denominator
outlier_introns = outlier_introns[outlier_counts, on = c("chrom", "samples"), nomatch = NULL]
```

```{r}
library(furrr)
plan(multisession, workers = availableCores())

denom = future_map_dbl(outlier_introns$frac, get_denom)
ir = future_map_dbl(outlier_introns$frac, frac_to_dbl)

outlier_introns$denom = denom
outlier_introns$ir = ir

```

```{r}
# add in reads
outlier_introns = melt(nums, id.vars = "chrom", variable.name = "samples", value.name = "rc")[
  outlier_introns, on = c("chrom", "samples"), nomatch = NULL
]

# artificially impute ir and rc when below condition meets
# the purpose is to remove ir=1 where read counts are low
outlier_introns[ir == 1 & rc < 10, `:=`(rc = 0, ir = 0)]
```

```{r}
# median IR per intron
outlier_introns[, median_ir := median(ir), by = chrom]
outlier_introns[, dist_ir := abs(median_ir - ir)]

# putative outlier
outlier_introns[, outlier := p < p_cutoff & denom > denom_cutoff & dist_ir > ir_dist_cutoff]

# outlier intron ids
outlier_introns_chroms = outlier_introns[outlier == T, chrom] %>% unique

outlier_introns = outlier_introns[chrom %in% outlier_introns_chroms]
```






 Some samples have many more outlier splicing events
```{r, width = 8}
outlier_introns[outlier == T][, .(N = length(unique(chrom))), by = samples] %>% 
  ggplot()  + geom_col(aes(fct_reorder(samples, -N), N, fill = samples)) + 
    geom_text_repel(aes(fct_reorder(samples, -N), N, label = samples), 
                    data = outlier_introns[outlier == T][, .(N = length(unique(chrom))), by = samples][N > 500]) + 
    labs(x = NULL) + 
    scale_y_log10() + 
    theme_bw() +
    theme(legend.position = "None", axis.text.x = element_blank())
```




#### Box plot before quantile filter

There are `r outlier_introns[outlier == T, chrom] %>% unique %>% length` outlier introns. 

```{r fig.width=10, fig.height=6, fig.cap="without filters"}

excl_samples = outlier_introns[ outlier == T, .( N = length(unique(chrom))), by = samples][N > 500, samples] %>% as.character
select_chroms = outlier_introns[!samples %in% excl_samples][order(p), chrom] %>% unique %>% head(50)

p2 = outlier_introns[chrom %in% select_chroms] %>% 
  ggplot() + geom_boxplot(aes(fct_reorder(chrom, p, min), ir)) + 
    geom_point(aes(fct_reorder(chrom, p, min), ir, color = outlier), alpha = .4) +
    geom_text_repel(aes(fct_reorder(chrom, p, min), ir, label = samples), 
                    data = outlier_introns[chrom %in% select_chroms & outlier == T & ir == 0]) + 
    labs(x = NULL, y = "Intron excision ratio") + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))

rasterize(p2, layers = "point", dpi=50)
```

```{r fig.width=10, fig.height=6}

excl_samples = outlier_introns[ outlier == T, .( N = length(unique(chrom))), by = samples][N > 500, samples] %>% as.character
select_chroms = outlier_introns[!samples %in% excl_samples][order(p), chrom] %>% unique %>% head(50)

p2 = outlier_introns[chrom %in% select_chroms] %>% 
  ggplot() + geom_boxplot(aes(fct_reorder(chrom, p, min), rc)) + 
    geom_point(aes(fct_reorder(chrom, p, min), rc, color = outlier), alpha = .4) +
    labs(x = NULL, y = "reads") + 
    scale_y_log10() + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))

rasterize(p2, layers = "point", dpi=50)
```

### Further filter outlier introns by comparing excision quantiles

By definition, outlier splicing events are ones that occur only in a few individuals. Here, I further enforced this quantile based filter: 

- assumes that it occurs in only up to 5% of samples,
- thus the excision ratio of the first 95% of samples should be largely different than that of the last 5% of samples
- here, I will only consider the case where the first 95% of samples have much lower excision ratio, because the complementary set always exists for a intron cluster. But we only want to select the intron once. 
- Specifically, an outlier intron is qualified only if the median excision ratio of samples in the (95, 100] percentiles is more than 2 std away from the median excision ratio of samples in the (0, 95] percentiles. 

In addition, for any intron usage of a sample where excision ratio is 1 and observed read counts < 10, read counts and excision ratio is forced to 0. This helps remove inflated excision ratio of 1 under such scenarios.




```{r}
qtPassed_chroms = outlier_introns[!samples %in% excl_samples, .(qtPass = quantilePass(ir)), by = chrom][qtPass == T, chrom] %>% unique
```


There are `r length(unique(qtPassed_chroms))` outlier introns after this round of quantil based filter. The box plot below randomly select 50 out of the outlier introns (x is sorted by p value). 

In summary, the two box plots below plotted some of the outlier introns that satisfy these crieria: 

  1.  p-value of a given intron excision event \< `r scales::scientific(p_cutoff)`
  2.  **AND** total reads of the cluster \> `r denom_cutoff`
  3. **AND** intron excision ratio is at least `r params$ir_dist_cutoff` away from median
  4. **AND** quantile filter described above
  5. **AND** exclude outliers from extrem samples


```{r, fig.width=12, fig.retina=T}

x = qtPassed_chroms[sample(1:length(qtPassed_chroms), 50)]

outlier_introns[chrom %in% x] %>% 
  ggplot() + geom_boxplot(aes(fct_reorder(chrom, p, min), ir)) + 
    geom_point(aes(fct_reorder(chrom, p, min), ir, color = outlier, shape = outlier), alpha = .4, position = "jitter") +
    geom_text_repel(aes(fct_reorder(chrom, p, min), ir, label = samples), 
                    data = outlier_introns[chrom %in% select_chroms & outlier == T & ir == 0]) + 
    labs(x = NULL, y = "Intron excision ratio") + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))
```

```{r, fig.width=12, fig.retina=T}
outlier_introns[chrom %in% x] %>% 
  ggplot() + geom_boxplot(aes(fct_reorder(chrom, p, min), rc)) + 
    geom_point(aes(fct_reorder(chrom, p, min), rc, color = outlier, shape = outlier), alpha = .4, position = "jitter") +
    scale_y_log10() + 
    labs(x = NULL, y = "reads") + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))
```




### extreme samples: `r excl_samples`

```{r}
samples_set1 = outlier_introns[outlier == T][
  , .(N = length(unique(chrom))), by = samples][
    N > 500, samples
  ] %>% as.character

samples_set2 = outlier_introns[outlier == T][
  , .(N = length(unique(chrom))), by = samples][
    N < 100, samples
  ] %>% as.character

GTEx = fread("../code/resources/snaptron-yil/scripts/data/samples_gtex.tsv")

```


Samples with > 500 outliers

```{r}
set1_gtex_ids = GTEx[rail_id %in% samples_set1][, SAMPID]
GTEx[rail_id %in% samples_set1][
  , .(rail_id, Sex, AGE, Histological_Type, Analyte_Type, SMPTHNTS, SMSMPSTE, SMSTYP, SMNABTCHT, TRTPTREF, DTHFUCOD, DTHMNNR, SAMPID)
]

```


Samples with less than 100 outliers
```{r}

GTEx[rail_id %in% samples_set2][
  , .(rail_id, Sex, AGE, Histological_Type, Analyte_Type, SMPTHNTS, SMSMPSTE, SMSTYP, SMNABTCHT, TRTPTREF, DTHFUCOD, DTHMNNR, SAMPID)
] %>% head
```

Notice the outlier sample is not included in the open access dataset from GTEx. One of the reasons may be that the sample did not pass QC filters.
```{r, include=TRUE}
# GTEx muscle TPM
gtex.tpm = fread("../code/resources/GTEx-downloads/gene_tpm_2017-06-05_v8_muscle_skeletal.gct.gz")
intersect(set1_gtex_ids, colnames(gtex.tpm))
# pca = prcomp(gtex.tpm[, 4:165] %>% t)
# 
# pca$x %>% as.data.frame %>% rownames_to_column("sampleID") %>%
#   select(1:5) %>% 
#   mutate(outlier = sampleID  %in% c("GTEX-VUSG-2626-SM-5S2TM"))
```



```{r include=FALSE}
rm(intron, counts, denom, outlier_introns, nums)
gc()
```



## `r params$group[[3]]`

```{r}
# load Bladder intron level pvals
tissue = params$tissue
group = params$group[[3]]
p_cutoff = as.numeric(params$p_cutoff)
denom_cutoff = as.numeric(params$denom_cutoff)
ir_dist_cutoff = as.numeric(params$ir_dist_cutoff)
```

```{r}
intron = fread(paste0("../code/results/leafcutterMD/GTEx/", tissue, "/",  group, "_pVals.txt.gz"))
#cluster = fread(paste0("../code/results/leafcutterMD/GTEx/", tissue , "/", group, "_clusterPvals.txt.gz"))
nums = fread(paste0("../code/results/SubsetCounts/GTEx/", tissue, "/nums_filtered/", group, "_perind.nums.gz"))
counts = fread(paste0("../code/results/SubsetCounts/GTEx/", tissue, "/counts/", group, "_perind.counts.gz"),
               header = T)

# rename first column
intron = rename(intron, "chrom" = "V1")
nums = rename(nums, "chrom" = "V1")

# add rowMin
intron_rowMins = select(intron, where(is_numeric)) %>% apply(1, min)
intron$rowMins = intron_rowMins # add min p-val per intron
```

### Intron selection

An intron excision is considered outlier only if: 

  1.  p-value of a given intron excision event \< `r scales::scientific(p_cutoff)`
  2.  **AND** total reads of the cluster \> `r denom_cutoff`
  3. **AND** intron excision ratio is at least `r params$ir_dist_cutoff` away from median

```{r}

# data.table of introns with that have outlier events
# note this is not the final outlier introns yet, as 
# we have to also filter by denominator
outlier_introns = intron[ rowMins < p_cutoff, -c('rowMins')] %>% unique

# get the counts of the same introns
outlier_counts = counts[chrom %in% outlier_introns$chrom]

# melt outlier intron and counts
outlier_introns = melt(outlier_introns, id.vars = "chrom", variable.name = "samples", value.name = "p")
outlier_counts = melt(outlier_counts, id.vars = "chrom", variable.name = "samples", value.name = "frac")

# further filter by denominator
outlier_introns = outlier_introns[outlier_counts, on = c("chrom", "samples"), nomatch = NULL]
```

```{r}
library(furrr)
plan(multisession, workers = availableCores())

denom = future_map_dbl(outlier_introns$frac, get_denom)
ir = future_map_dbl(outlier_introns$frac, frac_to_dbl)

outlier_introns$denom = denom
outlier_introns$ir = ir

```

```{r}
# add in reads
outlier_introns = melt(nums, id.vars = "chrom", variable.name = "samples", value.name = "rc")[
  outlier_introns, on = c("chrom", "samples"), nomatch = NULL
]

# artificially impute ir and rc when below condition meets
# the purpose is to remove ir=1 where read counts are low
outlier_introns[ir == 1 & rc < 10, `:=`(rc = 0, ir = 0)]
```

```{r}
# median IR per intron
outlier_introns[, median_ir := median(ir), by = chrom]
outlier_introns[, dist_ir := abs(median_ir - ir)]

# putative outlier
outlier_introns[, outlier := p < p_cutoff & denom > denom_cutoff & dist_ir > ir_dist_cutoff]

# outlier intron ids
outlier_introns_chroms = outlier_introns[outlier == T, chrom] %>% unique

outlier_introns = outlier_introns[chrom %in% outlier_introns_chroms]
```






 Some samples have many more outlier splicing events
```{r, width = 8}
outlier_introns[outlier == T][, .(N = length(unique(chrom))), by = samples] %>% 
  ggplot()  + geom_col(aes(fct_reorder(samples, -N), N, fill = samples)) + 
    geom_text_repel(aes(fct_reorder(samples, -N), N, label = samples), 
                    data = outlier_introns[outlier == T][, .(N = length(unique(chrom))), by = samples][N > 500]) + 
    labs(x = NULL) + 
    scale_y_log10() + 
    theme_bw() +
    theme(legend.position = "None", axis.text.x = element_blank())
```




#### Box plot before quantile filter

There are `r outlier_introns[outlier == T, chrom] %>% unique %>% length` outlier introns. 

```{r fig.width=10, fig.height=6, fig.cap="without filters"}

excl_samples = outlier_introns[ outlier == T, .( N = length(unique(chrom))), by = samples][N > 500, samples] %>% as.character
select_chroms = outlier_introns[!samples %in% excl_samples][order(p), chrom] %>% unique %>% head(50)

p2 = outlier_introns[chrom %in% select_chroms] %>% 
  ggplot() + geom_boxplot(aes(fct_reorder(chrom, p, min), ir)) + 
    geom_point(aes(fct_reorder(chrom, p, min), ir, color = outlier), alpha = .4) +
    geom_text_repel(aes(fct_reorder(chrom, p, min), ir, label = samples), 
                    data = outlier_introns[chrom %in% select_chroms & outlier == T & ir == 0]) + 
    labs(x = NULL, y = "Intron excision ratio") + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))

rasterize(p2, layers = "point", dpi=50)
```

```{r fig.width=10, fig.height=6}

excl_samples = outlier_introns[ outlier == T, .( N = length(unique(chrom))), by = samples][N > 500, samples] %>% as.character
select_chroms = outlier_introns[!samples %in% excl_samples][order(p), chrom] %>% unique %>% head(50)

p2 = outlier_introns[chrom %in% select_chroms] %>% 
  ggplot() + geom_boxplot(aes(fct_reorder(chrom, p, min), rc)) + 
    geom_point(aes(fct_reorder(chrom, p, min), rc, color = outlier), alpha = .4) +
    labs(x = NULL, y = "reads") + 
    scale_y_log10() + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))

rasterize(p2, layers = "point", dpi=50)
```

### Further filter outlier introns by comparing excision quantiles

By definition, outlier splicing events are ones that occur only in a few individuals. Here, I further enforced this quantile based filter: 

- assumes that it occurs in only up to 5% of samples,
- thus the excision ratio of the first 95% of samples should be largely different than that of the last 5% of samples
- here, I will only consider the case where the first 95% of samples have much lower excision ratio, because the complementary set always exists for a intron cluster. But we only want to select the intron once. 
- Specifically, an outlier intron is qualified only if the median excision ratio of samples in the (95, 100] percentiles is more than 2 std away from the median excision ratio of samples in the (0, 95] percentiles. 

In addition, for any intron usage of a sample where excision ratio is 1 and observed read counts < 10, read counts and excision ratio is forced to 0. This helps remove inflated excision ratio of 1 under such scenarios.




```{r}
qtPassed_chroms = outlier_introns[!samples %in% excl_samples, .(qtPass = quantilePass(ir)), by = chrom][qtPass == T, chrom] %>% unique
```


There are `r length(unique(qtPassed_chroms))` outlier introns after this round of quantil based filter. The box plot below randomly select 50 out of the outlier introns (x is sorted by p value). 

In summary, the two box plots below plotted some of the outlier introns that satisfy these crieria: 

  1.  p-value of a given intron excision event \< `r scales::scientific(p_cutoff)`
  2.  **AND** total reads of the cluster \> `r denom_cutoff`
  3. **AND** intron excision ratio is at least `r params$ir_dist_cutoff` away from median
  4. **AND** quantile filter described above
  5. **AND** exclude outliers from extrem samples


```{r, fig.width=12, fig.retina=T}

x = qtPassed_chroms[sample(1:length(qtPassed_chroms), 50)]

outlier_introns[chrom %in% x] %>% 
  ggplot() + geom_boxplot(aes(fct_reorder(chrom, p, min), ir)) + 
    geom_point(aes(fct_reorder(chrom, p, min), ir, color = outlier, shape = outlier), alpha = .4, position = "jitter") +
    geom_text_repel(aes(fct_reorder(chrom, p, min), ir, label = samples), 
                    data = outlier_introns[chrom %in% select_chroms & outlier == T & ir == 0]) + 
    labs(x = NULL, y = "Intron excision ratio") + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))
```

```{r, fig.width=12, fig.retina=T}
outlier_introns[chrom %in% x] %>% 
  ggplot() + geom_boxplot(aes(fct_reorder(chrom, p, min), rc)) + 
    geom_point(aes(fct_reorder(chrom, p, min), rc, color = outlier, shape = outlier), alpha = .4, position = "jitter") +
    scale_y_log10() + 
    labs(x = NULL, y = "reads") + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))
```




### extreme samples: `r excl_samples`

```{r}
samples_set1 = outlier_introns[outlier == T][
  , .(N = length(unique(chrom))), by = samples][
    N > 500, samples
  ] %>% as.character

samples_set2 = outlier_introns[outlier == T][
  , .(N = length(unique(chrom))), by = samples][
    N < 100, samples
  ] %>% as.character

GTEx = fread("../code/resources/snaptron-yil/scripts/data/samples_gtex.tsv")

```


Samples with > 500 outliers

```{r}
set1_gtex_ids = GTEx[rail_id %in% samples_set1][, SAMPID]
GTEx[rail_id %in% samples_set1][
  , .(rail_id, Sex, AGE, Histological_Type, Analyte_Type, SMPTHNTS, SMSMPSTE, SMSTYP, SMNABTCHT, TRTPTREF, DTHFUCOD, DTHMNNR, SAMPID)
]

```


Samples with less than 100 outliers
```{r}

GTEx[rail_id %in% samples_set2][
  , .(rail_id, Sex, AGE, Histological_Type, Analyte_Type, SMPTHNTS, SMSMPSTE, SMSTYP, SMNABTCHT, TRTPTREF, DTHFUCOD, DTHMNNR, SAMPID)
] %>% head
```

Notice the outlier sample is not included in the open access dataset from GTEx. One of the reasons may be that the sample did not pass QC filters.
```{r, include=TRUE}
# GTEx muscle TPM
gtex.tpm = fread("../code/resources/GTEx-downloads/gene_tpm_2017-06-05_v8_muscle_skeletal.gct.gz")
intersect(set1_gtex_ids, colnames(gtex.tpm))
# pca = prcomp(gtex.tpm[, 4:165] %>% t)
# 
# pca$x %>% as.data.frame %>% rownames_to_column("sampleID") %>%
#   select(1:5) %>% 
#   mutate(outlier = sampleID  %in% c("GTEX-VUSG-2626-SM-5S2TM"))
```



```{r include=FALSE}
rm(intron, counts, denom, outlier_introns, nums)
gc()
```
